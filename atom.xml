<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fightbeast</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-02-07T07:51:44.118Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>fightbeast</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法框架</title>
    <link href="http://yoursite.com/2021/02/07/%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2021/02/07/%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/</id>
    <published>2021-02-07T07:50:42.000Z</published>
    <updated>2021-02-07T07:51:44.118Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-排序函数"><a href="#1-排序函数" class="headerlink" title="1. 排序函数"></a>1. 排序函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Java排序函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intervalSchedule</span><span class="params">(<span class="keyword">int</span>[][] intvs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (intvs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 按 end 升序排序</span></span><br><span class="line">    Arrays.sort(intvs, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 至少有一个区间不相交</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 排序后，第一个区间就是 x</span></span><br><span class="line">    <span class="keyword">int</span> x_end = intvs[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] interval : intvs) &#123;</span><br><span class="line">        <span class="keyword">int</span> start = interval[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= x_end) &#123;</span><br><span class="line">            <span class="comment">// 找到下一个选择的区间了</span></span><br><span class="line">            count++;</span><br><span class="line">            x_end = interval[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-动归框架"><a href="#2-动归框架" class="headerlink" title="2. 动归框架"></a>2. 动归框架</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (状态<span class="number">1</span> : 状态<span class="number">1</span>的所有取值)&#123;</span><br><span class="line"><span class="keyword">for</span> (状态<span class="number">2</span> : 状态<span class="number">2</span>的所有取值)&#123;</span><br><span class="line"><span class="keyword">for</span>  ...</span><br><span class="line">dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 择优(选择<span class="number">1</span>，选择<span class="number">2</span>，...);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-回溯框架"><a href="#3-回溯框架" class="headerlink" title="3. 回溯框架"></a>3. 回溯框架</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">backtrack</span><span class="params">(路径, 选择列表)</span>:</span></span><br><span class="line"><span class="function">    <span class="keyword">if</span> 满足结束条件:</span></span><br><span class="line"><span class="function">        result.<span class="title">add</span><span class="params">(路径)</span></span></span><br><span class="line"><span class="function">        return</span></span><br><span class="line"><span class="function">    <span class="keyword">for</span> 选择 in 选择列表:</span></span><br><span class="line"><span class="function">        做选择</span></span><br><span class="line"><span class="function">        <span class="title">backtrack</span><span class="params">(路径, 选择列表)</span></span></span><br><span class="line"><span class="function">        撤销选择</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 回溯算法模板 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> rest)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (i == nums.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rest == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 说明恰好凑出 target</span></span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 给 nums[i] 选择 - 号</span></span><br><span class="line">    rest += nums[i];</span><br><span class="line">    <span class="comment">// 穷举 nums[i + 1]</span></span><br><span class="line">    backtrack(nums, i + <span class="number">1</span>, rest);</span><br><span class="line">    <span class="comment">// 撤销选择</span></span><br><span class="line">    rest -= nums[i]; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给 nums[i] 选择 + 号</span></span><br><span class="line">    rest -= nums[i];</span><br><span class="line">    <span class="comment">// 穷举 nums[i + 1]</span></span><br><span class="line">    backtrack(nums, i + <span class="number">1</span>, rest);</span><br><span class="line">    <span class="comment">// 撤销选择</span></span><br><span class="line">    rest += nums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-快排框架"><a href="#4-快排框架" class="headerlink" title="4. 快排框架"></a>4. 快排框架</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 快速排序主函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一般要在这用洗牌算法将 nums 数组打乱，</span></span><br><span class="line">    <span class="comment">// 以保证较高的效率，我们暂时省略这个细节</span></span><br><span class="line">    sort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 快速排序核心逻辑 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 通过交换元素构建分界点索引 p</span></span><br><span class="line">    <span class="keyword">int</span> p = partition(nums, lo, hi);</span><br><span class="line">    <span class="comment">// 现在 nums[lo..p-1] 都小于 nums[p]，</span></span><br><span class="line">    <span class="comment">// 且 nums[p+1..hi] 都大于 nums[p]</span></span><br><span class="line">    sort(nums, lo, p - <span class="number">1</span>);</span><br><span class="line">    sort(nums, p + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo == hi) <span class="keyword">return</span> lo;</span><br><span class="line">    <span class="comment">// 将 nums[lo] 作为默认分界点 pivot</span></span><br><span class="line">    <span class="keyword">int</span> pivot = nums[lo];</span><br><span class="line">    <span class="comment">// j = hi + 1 因为 while 中会先执行 --</span></span><br><span class="line">    <span class="keyword">int</span> i = lo, j = hi + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 保证 nums[lo..i] 都小于 pivot</span></span><br><span class="line">        <span class="keyword">while</span> (nums[++i] &lt; pivot) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == hi) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保证 nums[j..hi] 都大于 pivot</span></span><br><span class="line">        <span class="keyword">while</span> (nums[--j] &gt; pivot) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == lo) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 如果走到这里，一定有：</span></span><br><span class="line">        <span class="comment">// nums[i] &gt; pivot &amp;&amp; nums[j] &lt; pivot</span></span><br><span class="line">        <span class="comment">// 所以需要交换 nums[i] 和 nums[j]，</span></span><br><span class="line">        <span class="comment">// 保证 nums[lo..i] &lt; pivot &lt; nums[j..hi]</span></span><br><span class="line">        swap(nums, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将 pivot 值交换到正确的位置</span></span><br><span class="line">    swap(nums, j, lo);</span><br><span class="line">    <span class="comment">// 现在 nums[lo..j-1] &lt; nums[j] &lt; nums[j+1..hi]</span></span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-滑动窗口框架"><a href="#5-滑动窗口框架" class="headerlink" title="5. 滑动窗口框架"></a>5. 滑动窗口框架</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 滑动窗口算法框架 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slidingWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.size()) &#123;</span><br><span class="line">        <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        <span class="comment">// 右移窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*** debug 输出的位置 ***/</span></span><br><span class="line">        printf(<span class="string">"window: [%d, %d)\n"</span>, left, right);</span><br><span class="line">        <span class="comment">/********************/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            <span class="comment">// 左移窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-二分框架"><a href="#6-二分框架" class="headerlink" title="6. 二分框架"></a>6. 二分框架</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 直接返回</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接返回</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 别返回，锁定左侧边界</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后要检查 left 越界的情况</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= nums.length || nums[left] != target)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 别返回，锁定右侧边界</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后要检查 right 越界的情况</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; <span class="number">0</span> || nums[right] != target)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-twoSum框架"><a href="#7-twoSum框架" class="headerlink" title="7. twoSum框架"></a>7. twoSum框架</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; twoSumTarget(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="comment">// nums 数组必须有序</span></span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.size() - <span class="number">1</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = nums[lo] + nums[hi];</span><br><span class="line">        <span class="keyword">int</span> left = nums[lo], right = nums[hi];</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">            <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[lo] == left) lo++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[hi] == right) hi--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.push_back(&#123;left, right&#125;);</span><br><span class="line">            <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[lo] == left) lo++;</span><br><span class="line">            <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[hi] == right) hi--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-BFS框架"><a href="#8-BFS框架" class="headerlink" title="8. BFS框架"></a>8. BFS框架</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算从起点 start 到终点 target 的最近距离</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(Node start, Node target)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Node&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">// 核心数据结构</span></span><br><span class="line">    Set&lt;Node&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;(); <span class="comment">// 避免走回头路</span></span><br><span class="line"></span><br><span class="line">    q.offer(start); <span class="comment">// 将起点加入队列</span></span><br><span class="line">    visited.add(start);</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>; <span class="comment">// 记录扩散的步数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q not empty) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="comment">/* 将当前队列中的所有节点向四周扩散 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            Node cur = q.poll();</span><br><span class="line">            <span class="comment">/* 划重点：这里判断是否到达终点 */</span></span><br><span class="line">            <span class="keyword">if</span> (cur is target)</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            <span class="comment">/* 将 cur 的相邻节点加入队列 cur.adj()泛指cur相邻的节点 */</span></span><br><span class="line">            <span class="keyword">for</span> (Node x : cur.adj())</span><br><span class="line">                <span class="keyword">if</span> (x not in visited) &#123;</span><br><span class="line">                    q.offer(x);</span><br><span class="line">                    visited.add(x);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 划重点：更新步数在这里 */</span></span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-股票问题-状态机"><a href="#9-股票问题-状态机" class="headerlink" title="9. 股票问题-状态机"></a>9. 股票问题-状态机</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算从起点 start 到终点 target 的最近距离</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit_k_infinity</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = prices.length;</span><br><span class="line">     <span class="comment">// base case: dp[-1][0] = 0; dp[-1][1] = Integer.MIN_VALUE; </span></span><br><span class="line">    <span class="keyword">int</span> dp_i_0 = <span class="number">0</span>, dp_i_1 = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> temp = dp_i_0;</span><br><span class="line"><span class="comment">//dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</span></span><br><span class="line">dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);</span><br><span class="line"><span class="comment">//dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])</span></span><br><span class="line">dp_i_1 = Math.max(dp_i_1, temp - prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_i_0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-排序函数&quot;&gt;&lt;a href=&quot;#1-排序函数&quot; class=&quot;headerlink&quot; title=&quot;1. 排序函数&quot;&gt;&lt;/a&gt;1. 排序函数&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gu</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>2019总结</title>
    <link href="http://yoursite.com/2020/01/09/2019%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/01/09/2019%E6%80%BB%E7%BB%93/</id>
    <published>2020-01-09T10:40:06.000Z</published>
    <updated>2020-01-09T14:00:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2019年度总结"><a href="#2019年度总结" class="headerlink" title="2019年度总结"></a>2019年度总结</h2><p>秉承着一贯的传统，这次的年终总结也拖延了，而且拖延了一周，周遭的世界变化很快，不变的，是我的拖延。可能很多年后回头看，19年会是我人生的一大转折点，是福是祸尚且未知，只能先谨慎的记录下来。</p><h3 id="过去"><a href="#过去" class="headerlink" title="过去"></a>过去</h3><p>今年最大的收获当然是告别单身状态了，也算完成了去年最大的FLAG了。异地恋很难，但是爱的人给我的能量更多，悄悄感谢一下小专同学。</p><p>工作方面的FLAG都没能回收。求职目标从游戏策划到产品经理，最后突然坚定走技术方向，虽然做了一些自以为足够的准备，但是还是在秋招惨败，签约的公司有些流言蜚语，希望自己入职之后可以找到自己的位置吧，也要做好最坏的打算。当然，经过两年的思考，发现技术方向确实是目前最适合自己的方向，自己也越来越喜欢技术，也不赖吧。</p><p>“努力工作是为了更好的生活。”三流如是说。今年更多的独处时间变成了情感交流，这也是异地恋要付出的代价。在其他我还能把握的独处时间里，各种爱好的行为方式都发生一些改变。听音乐变成了听电台，看DOTA直播变成了看直播集锦，游戏也玩的少了许多。不过B站还是没有少看的，恋爱CP视频看了不少，RYU&amp;YUMA，瑞&amp;拿还是很甜的，还是有很多东西要学的。当然非独处时间也是生活，北京合肥两次Live，宁波北京杭州天津长春几次聚会约会，德清舟山两次出差确实难忘。希望明年能扩展生活的更多可能性。</p><p>“贼不走空”，经历过的事情都要留下些东西。弦计划的peer pressure让我开始做自己的社群，做自己的APP，准备游戏和产品的经历也让我养成了看游戏设计和产品方法论的习惯，实验室的工作让我习惯了乙方心态，希望能保持住这些好的东西。</p><p>总结下来就是，还要热爱生活，还要向着太阳。</p><h3 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h3><ol><li>最大目标是通过一些输出切实的提升文笔。</li><li>工作上Make impact。</li><li>游戏梦还没有灭，希望可以参加一次GameJam。</li><li>坚持把一些尝试完成，刷闪群，宝可梦蛋友不要半途而废。</li><li>看心情完成以下一项吧，N3日语，驾驶证，乐器。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2019年度总结&quot;&gt;&lt;a href=&quot;#2019年度总结&quot; class=&quot;headerlink&quot; title=&quot;2019年度总结&quot;&gt;&lt;/a&gt;2019年度总结&lt;/h2&gt;&lt;p&gt;秉承着一贯的传统，这次的年终总结也拖延了，而且拖延了一周，周遭的世界变化很快，不变的，是我的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CSAPP</title>
    <link href="http://yoursite.com/2019/12/03/CSAPP/"/>
    <id>http://yoursite.com/2019/12/03/CSAPP/</id>
    <published>2019-12-03T06:01:51.000Z</published>
    <updated>2020-01-08T06:37:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>你在代码里，有过哪些提升Java内存性能的措施，或者问，你在java虚拟机优化方面做过哪些工作？数据库方面，除了增删改查等基本技能点之外，你还有哪些提升数据库性能（比如SQL调优）的经验。在大数据库等方面，你有哪些实践经验？你是否搭建过系统架构，比如让你设计一个秒杀系统，你需要考虑哪些方面的因素？选用哪些方面的组件。在设计一个成熟稳定的系统时，你需要考虑哪些因素？你说下这方面的实践经验。</p><p>基础知识一定得扎实，比如java方面，集合，多线程，spring boot等方面，最好了解下底层代码实现。什么技能点都应当向“优化”方面靠，比如一段代码如何实现性能优化，访问数据库如何实现返回效果最快，一个架构如何实现“高可用”的效果。最好实现全栈，前端，后端，数据库，还有Linux部署，上线后如何通过日志排查问题，这都该懂些。</p><p>【日期】：2004-08-17<br>【问题】：当解码 Q.931 信令时无限循环<br>【原因】：当在Q.931信令中发现一个未知的元素id时，我们试图通过读取它的长度来跳过它，并且将位置指针迁移几个字节。但是，在这个例子中的长度是零，导致我们反复跳过相同的元素id。<br>【怎么发现的】：在解码一个 Ethereal 从 Nortel 追踪到的安装信息时发现了这个问题。他们的信息是 1016 字节长度（包含大量快速启动元素），但我们的 MSG_MAX_LEN 是 1000。通常我们会收到一条来自 common/Communication.cxx 的信息，但现在，当直接输入需要解析的数据时，数组末端内存访问越界，其恰好是 0，暴露了这个问题。 为了找到它，我仅仅在 9931 解码中添加一些打印输出。但很幸运数据恰好是零。<br>【修复】：如果长度是零，设置为 1。这方式总是行得通。<br>【在哪些文件修改了】： callh/q931_msg.cxx callh/q931_msg.cxx<br>【我导致的】：是的  【解决Bug的时间】：1小时<br>【教训】：信任收到信息中获得的数据。不仅仅是产生大量可能导致问题的数据。显示长度为 0 也同样不好。<br><img alt="1" data-src="http://q23472wnu.bkt.clouddn.com/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20191203144959.jpg" class="lazyload"></p><p>用布隆过滤器解决缓存穿透<br>tomcat 500个请求<br>redis 1秒十万<br>nginx 分流<br>Redis 实现分布式锁 多对一操作 有状态的资源</p><p>快速消费品 市场部 扩大你的需求 创造你的需求</p><p>两个问题</p><ol><li>@Resource和@Autowired的区别</li><li>@Repository @Component @Service和@Contorller之间的区别与联系</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;你在代码里，有过哪些提升Java内存性能的措施，或者问，你在java虚拟机优化方面做过哪些工作？数据库方面，除了增删改查等基本技能点之外，你还有哪些提升数据库性能（比如SQL调优）的经验。在大数据库等方面，你有哪些实践经验？你是否搭建过系统架构，比如让你设计一个秒杀系统，你</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>11-30-文章总结</title>
    <link href="http://yoursite.com/2019/12/01/11-30-%E6%96%87%E7%AB%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/12/01/11-30-%E6%96%87%E7%AB%A0%E6%80%BB%E7%BB%93/</id>
    <published>2019-12-01T06:14:25.000Z</published>
    <updated>2019-12-01T06:16:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java服务端常见问题"><a href="#Java服务端常见问题" class="headerlink" title="Java服务端常见问题"></a><a href="https://mp.weixin.qq.com/s/mTl551gMuHuX_SXpYEELxA" target="_blank" rel="noopener">Java服务端常见问题</a></h2><h3 id="分布式系统问题"><a href="#分布式系统问题" class="headerlink" title="分布式系统问题"></a>分布式系统问题</h3><p>Java的synchronized关键字只在一个虚拟机内生效。</p><a id="more"></a><h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><p>目前，主流的分布式锁实现方式有3种：</p><ul><li>基于数据库实现的分布式锁；</li><li>基于Redis实现的分布式锁；</li><li>基于Zookeeper实现的分布式锁。</li></ul><h4 id="分布式消息"><a href="#分布式消息" class="headerlink" title="分布式消息"></a>分布式消息</h4><p>分布式消息中间件是支持在分布式系统中发送和接受消息的软件基础设施。常见的分布式消息中间件有ActiveMQ、RabbitMQ、Kafka、MetaQ等。</p><h4 id="数据库分片分组"><a href="#数据库分片分组" class="headerlink" title="数据库分片分组"></a>数据库分片分组</h4><ul><li><p>分片(shard)：主要解决扩展性问题，属于水平拆分。引入分片，就引入了数据路由和分区键的概念。其中，分表解决的是数据量过大的问题，分库解决的是数据库性能瓶颈的问题。</p></li><li><p>分组(group)：主要解决可用性问题，通过主从复制的方式实现，并提供读写分离策略用以提高数据库性能。</p></li></ul><h4 id="分布式计算"><a href="#分布式计算" class="headerlink" title="分布式计算"></a>分布式计算</h4><h4 id="分布式硬件部署方案"><a href="#分布式硬件部署方案" class="headerlink" title="分布式硬件部署方案"></a>分布式硬件部署方案</h4><h3 id="多线程问题"><a href="#多线程问题" class="headerlink" title="多线程问题"></a>多线程问题</h3><p>多线程优化慢接口</p><ul><li>新线程</li><li>消息队列</li></ul><h3 id="流程定义不合理"><a href="#流程定义不合理" class="headerlink" title="流程定义不合理"></a>流程定义不合理</h3><p>有限状态机实现</p><h3 id="系统间交互"><a href="#系统间交互" class="headerlink" title="系统间交互"></a>系统间交互</h3><p>Dubbo实现</p><h4 id="常见系统间交互方式"><a href="#常见系统间交互方式" class="headerlink" title="常见系统间交互方式"></a>常见系统间交互方式</h4><ol><li>请求-应答</li><li>通知-确认</li><li>请求-应答-查询-返回</li><li>请求-应答-回调</li><li>请求-应答-通知-确认</li><li>通知-确认-通知-确认<h3 id="数据查询不分页"><a href="#数据查询不分页" class="headerlink" title="数据查询不分页"></a>数据查询不分页</h3>解决方案</li><li>设置最大数量 相当于只返回第一页数据</li><li>采用分页查询<br>（扩展阅读：<strong>《那些年，我们见过的Java服务端“乱象”》</strong>）</li></ol><h2 id="端智能"><a href="#端智能" class="headerlink" title="端智能"></a><a href="https://mp.weixin.qq.com/s/S_tEgLQk5zB3T4l0fqJ6JQ" target="_blank" rel="noopener">端智能</a></h2><h4 id="痛点"><a href="#痛点" class="headerlink" title="痛点"></a>痛点</h4><ul><li>云端推荐系统对终端用户推荐内容调整机会少，往往都在分页请求时，而简单请求并不能<strong>灵活做内容的增删改</strong></li><li>云端推荐系统不能及时获取到用户当前时刻的偏好意图，快速给出反馈</li></ul><p><strong>边缘计算</strong>相关内容 后面讲的不是很细</p><h2 id="高德地图地理文本处理"><a href="#高德地图地理文本处理" class="headerlink" title="高德地图地理文本处理"></a><a href="https://mp.weixin.qq.com/s/sJvh4ZKIYWNo87pI69LvFA" target="_blank" rel="noopener">高德地图地理文本处理</a></h2><h4 id="地图App"><a href="#地图App" class="headerlink" title="地图App"></a>地图App</h4><p>地图App的功能可以简单概括为<strong>定位，搜索，导航</strong>三部分，分别解决在哪里，去哪里，和怎么去的问题。<br>高德地图的搜索场景下，输入的是，地理相关的检索query，用户位置，App图面等信息，输出的是，用户想要的POI。<br>一个搜索引擎通常可以拆分成<strong>query分析、召回、排序</strong>三个部分<br>(后面是NLP相关内容 没有仔细看了)</p><h2 id="今日头条消息系统RocketMQ"><a href="#今日头条消息系统RocketMQ" class="headerlink" title="今日头条消息系统RocketMQ"></a><a href="https://mp.weixin.qq.com/s/mrV77AXBq4bNMKdE8M5I0g" target="_blank" rel="noopener">今日头条消息系统RocketMQ</a></h2><h3 id="业务背景"><a href="#业务背景" class="headerlink" title="业务背景"></a>业务背景</h3><h4 id="NSQ"><a href="#NSQ" class="headerlink" title="NSQ"></a>NSQ</h4><ul><li>是纯内存的消息队列，<strong>缺少消息的持久性</strong>，不落盘直接写到 Golang 的 channel 里，在<strong>并发量高的时候 CPU 利用率非常高</strong>，</li><li>其优点是可以无限水平扩展，另外，由于不需要保证消息的有序性，集群单点故障对可用性基本没有影响，所以具有<strong>非常高的可用性</strong>。</li></ul><h4 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h4><ul><li>它的主要问题是在业务线和 Topic 繁多，其写入性能会出现明显的下降，</li><li>拆分集群又会增加额外的运维负担。并且在高负载下，其故障恢复时间比较长。</li></ul><h4 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h4><ul><li>支持亿级并发的开源消息队列。RocketMQ 具有高可靠性、数据持久性，和 Kafka 一样是先写 PageCache ，再落盘，并且数据有多副本；并且它的存储模型是所有的 Topic 都写到同一个 Commitlog 里，是一个append only 操作，在海量 Topic 下也能将磁盘的性能发挥到极致，并且保持稳定的写入时延。</li><li>对比之前的 NSQ 和 Kafka ， Kafka 的吞吐非常高，但是在多 Topic 下， Kafka 的 PCT99 毛刺会非常多,而且平均值非常长，不适合在线业务场景。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Java服务端常见问题&quot;&gt;&lt;a href=&quot;#Java服务端常见问题&quot; class=&quot;headerlink&quot; title=&quot;Java服务端常见问题&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/mTl551gMuHuX_SXpYEELxA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java服务端常见问题&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;分布式系统问题&quot;&gt;&lt;a href=&quot;#分布式系统问题&quot; class=&quot;headerlink&quot; title=&quot;分布式系统问题&quot;&gt;&lt;/a&gt;分布式系统问题&lt;/h3&gt;&lt;p&gt;Java的synchronized关键字只在一个虚拟机内生效。&lt;/p&gt;</summary>
    
    
    
    
    <category term="文章总结" scheme="http://yoursite.com/tags/文章总结/"/>
    
  </entry>
  
  <entry>
    <title>技术文章聚合 11.23</title>
    <link href="http://yoursite.com/2019/11/23/11-23-%E6%96%87%E7%AB%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/11/23/11-23-%E6%96%87%E7%AB%A0%E6%80%BB%E7%BB%93/</id>
    <published>2019-11-23T06:31:43.000Z</published>
    <updated>2019-12-25T11:11:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a><a href="https://mp.weixin.qq.com/s/7RcVjn8wldpPhUxftUVhDA" target="_blank" rel="noopener">Zookeeper</a></h2><h3 id="什么是ZooKeeper"><a href="#什么是ZooKeeper" class="headerlink" title="什么是ZooKeeper"></a>什么是ZooKeeper</h3><ul><li>ZooKeeper主要服务于分布式系统，可以用ZooKeeper来做：统一配置管理、统一命名服务、分布式锁、集群管理。</li><li>ZooKeeper的数据结构，跟Unix文件系统非常类似，可以看做是一颗树，每个节点叫做ZNode。<a id="more"></a></li></ul><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a><a href="https://mp.weixin.qq.com/s/05pAyDo8sR-oBjgSa7f3IQ" target="_blank" rel="noopener">消息队列</a></h2><h3 id="消息队列特点"><a href="#消息队列特点" class="headerlink" title="消息队列特点"></a>消息队列特点</h3><ul><li>解耦</li><li>异步</li><li>削峰，限流<br>TODO：各种消息队列的特点</li></ul><h2 id="一行SQL语句执行的很慢的原因"><a href="#一行SQL语句执行的很慢的原因" class="headerlink" title="一行SQL语句执行的很慢的原因"></a><a href="https://mp.weixin.qq.com/s/y3pn-LMs08p3ucs-WADPFA" target="_blank" rel="noopener">一行SQL语句执行的很慢的原因</a></h2><h3 id="大多数情况正常，偶尔很慢的情况"><a href="#大多数情况正常，偶尔很慢的情况" class="headerlink" title="大多数情况正常，偶尔很慢的情况"></a>大多数情况正常，偶尔很慢的情况</h3><ol><li>数据库在刷新脏页</li><li>拿不到锁 (用 show processlist 查看当前状态)</li></ol><h3 id="一直很慢"><a href="#一直很慢" class="headerlink" title="一直很慢"></a>一直很慢</h3><ol><li>没有用到索引</li><li>有的时候系统自己不走索引(复杂，可见文章)</li></ol><h2 id="线程池学习总结"><a href="#线程池学习总结" class="headerlink" title="线程池学习总结"></a><a href="https://mp.weixin.qq.com/s/HCwCJw5CCDsue6H5XHfO0g" target="_blank" rel="noopener">线程池学习总结</a></h2><h3 id="使用线程池的好处"><a href="#使用线程池的好处" class="headerlink" title="使用线程池的好处"></a>使用线程池的好处</h3><p>这里借用《Java 并发编程的艺术》提到的来说一下使用线程池的好处：</p><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h3 id="Executor框架结构"><a href="#Executor框架结构" class="headerlink" title="Executor框架结构"></a>Executor框架结构</h3><ol><li>任务(Runnable/Callable)</li><li>任务的执行(ThreadPoolExecutor)</li><li>异步计算的结果(Future)</li></ol><h3 id="Notice"><a href="#Notice" class="headerlink" title="Notice"></a>Notice</h3><ol><li>工具类 Executors 可以实现 Runnable 对象和 Callable 对象之间的相互转换。</li><li>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</li><li>submit()方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执行成功，并且可以通过 Future 的 get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用 get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li></ol><h2 id="在闲鱼用户增长业务上的实验"><a href="#在闲鱼用户增长业务上的实验" class="headerlink" title="在闲鱼用户增长业务上的实验"></a><a href="https://mp.weixin.qq.com/s/XwDFNjE7BbzVslcbqMISoA" target="_blank" rel="noopener">在闲鱼用户增长业务上的实验</a></h2><p>基于事件流的 <strong>规则引擎EPL</strong></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Zookeeper&quot;&gt;&lt;a href=&quot;#Zookeeper&quot; class=&quot;headerlink&quot; title=&quot;Zookeeper&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/7RcVjn8wldpPhUxftUVhDA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Zookeeper&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;什么是ZooKeeper&quot;&gt;&lt;a href=&quot;#什么是ZooKeeper&quot; class=&quot;headerlink&quot; title=&quot;什么是ZooKeeper&quot;&gt;&lt;/a&gt;什么是ZooKeeper&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;ZooKeeper主要服务于分布式系统，可以用ZooKeeper来做：统一配置管理、统一命名服务、分布式锁、集群管理。&lt;/li&gt;
&lt;li&gt;ZooKeeper的数据结构，跟Unix文件系统非常类似，可以看做是一颗树，每个节点叫做ZNode。</summary>
    
    
    
    
    <category term="文章总结" scheme="http://yoursite.com/tags/文章总结/"/>
    
  </entry>
  
  <entry>
    <title>问题整理</title>
    <link href="http://yoursite.com/2019/09/27/hello-world/"/>
    <id>http://yoursite.com/2019/09/27/hello-world/</id>
    <published>2019-09-27T07:30:16.000Z</published>
    <updated>2019-09-27T11:55:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="问：SpringMVC-原理了解吗"><a href="#问：SpringMVC-原理了解吗" class="headerlink" title="问：SpringMVC 原理了解吗?"></a>问：SpringMVC 原理了解吗?</h2><p>客户端发送请求-&gt; 前端控制器 DispatcherServlet 接受客户端请求 -&gt; 找到处理器映射 HandlerMapping 解析请求对应的 Handler-&gt; HandlerAdapter 会根据 Handler 来调用真正的处理器处理请求，并处理相应的业务逻辑 -&gt; 处理器返回一个模型视图 ModelAndView -&gt; 视图解析器进行解析 -&gt; 返回一个视图对象-&gt;前端控制器 DispatcherServlet 渲染数据（Model）-&gt;将得到视图对象返回给用户</p><a id="more"></a><h2 id="问：Mybatis常用-还是"><a href="#问：Mybatis常用-还是" class="headerlink" title="问：Mybatis常用#还是$"></a>问：Mybatis常用#还是$</h2><p>#是将传入的值当做字符串的形式<br>$是将传入的数据直接显示生成sql语句</p><h1 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h1><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md</a></p><h2 id="问-转发与重定向"><a href="#问-转发与重定向" class="headerlink" title="问:转发与重定向"></a>问:转发与重定向</h2><p><strong>转发是服务器行为，重定向是客户端行为。</strong></p><p><strong>转发（Forword）</strong> 通过RequestDispatcher对象的<code>forward（HttpServletRequest request,HttpServletResponse response）</code>方法实现的。<code>RequestDispatcher</code> 可以通过<code>HttpServletRequest</code> 的 <code>getRequestDispatcher()</code>方法获得。例如下面的代码就是跳转到 login_success.jsp 页面。<br><strong>重定向（Redirect）</strong> 是利用服务器返回的状态码来实现的。客户端浏览器请求服务器的时候，服务器会返回一个状态码。服务器通过HttpServletRequestResponse的setStatus(int status)方法设置状态码。如果服务器返回301或者302，则浏览器会到新的网址重新请求该资源。</p><ol><li><strong>从地址栏显示来说</strong>：forward是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器。浏览器根本不知道服务器发送的内容从哪里来的，所以它的地址栏还是原来的地址。redirect是服务端根据逻辑，发送一个状态码，告诉浏览器重新去请求那个地址。所以地址栏显示的是新的URL。</li><li><strong>从数据共享来说</strong>：forward：转发页面和转发到的页面可以共享request里面的数据。redirect：不能共享数据。</li><li><strong>从运用地方来说</strong>：forward：一般用于用户登陆的时候，根据角色转发到相应的模块。redirect：一般用于用户注销登陆时返回主页面和跳转到其它的网站等。</li><li><strong>从效率来说</strong>：forward：高。redirect：低。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.getRequestDispatcher(&quot;login_success.jsp&quot;).forward(request, response);</span><br></pre></td></tr></table></figure></li></ol><h2 id="问-URL输入之后的过程"><a href="#问-URL输入之后的过程" class="headerlink" title="问: URL输入之后的过程"></a>问: URL输入之后的过程</h2><ul><li>DNS解析  </li><li>TCP连接  </li><li>发送HTTP请求    </li><li>服务器处理请求并返回HTTP报文  </li><li>浏览器解析渲染页面  </li><li>连接结束</li></ul><p>具体请见<br><a href="https://segmentfault.com/a/1190000006879700?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006879700?utm_source=tag-newest</a></p><h2 id="问-常见HTTP状态码"><a href="#问-常见HTTP状态码" class="headerlink" title="问: 常见HTTP状态码"></a>问: 常见HTTP状态码</h2><p>200, 204, 301, 302, 304, 400, 401, 403, 404, 422, 500</p><p>| ** 状态码 **   | ** 类别 **   | ** 含义 **   |<br>|:—-:|:—-:|:—-:|:—-:|:—-:|:—-:|<br>|  1XX    |  Informational（信息性状态码）    |  接收的请求正在处理    |<br>|  2XX    |  Success（成功状态码）    |  请求正常处理完毕    |<br>|  3XX    |  Redirection（重定向状态码）    |  需要进行附加操作以完成请求    |<br>|  4XX    |  Client Error（客户端错误状态码）    |  服务器无法处理请求    |<br>|  5XX    |  Server Error（服务器错误状态码）    |  服务器处理请求出错    |</p><p>101： 转换协议 在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。只有在切换新的协议更有好处的时候才应该采取类似措施。</p><p>102：继续处理 由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。</p><p><strong>200：请求成功 处理方式：获得响应的内容，进行处理</strong></p><p>201：请求完成，结果是创建了新资源。新创建资源的URI可在响应的实体中得到 处理方式：爬虫中不会遇到</p><p>202：请求被接受，但处理尚未完成 处理方式：阻塞等待</p><p>204：服务器端已经实现了请求，但是没有返回新的信 息。如果客户是用户代理，则无须为此更新自身的文档视图。 处理方式：丢弃</p><p>300：该状态码不被HTTP/1.0的应用程序直接使用， 只是作为3XX类型回应的默认解释。存在多个可用的被请求资源。 处理方式：若程序中能够处理，则进行进一步处理，如果程序中不能处理，则丢弃<br><strong>301：永久重定向。</strong>请求到的资源都会分配一个永久的URL，这样就可以在将来通过该URL来访问此资源 处理方式：重定向到分配的URL</p><p><strong>302：临时重定向。</strong>请求到的资源在一个不同的URL处临时保存 处理方式：重定向到临时的URL</p><p>*<em>304：请求的资源未更新 *</em>处理方式：丢弃</p><p><strong>400：非法请求</strong> 处理方式：丢弃</p><p><strong>401：未授权</strong> 处理方式：丢弃</p><p>*<em>403：禁止 *</em>处理方式：丢弃</p><p>*<em>404：没有找到 *</em>处理方式：丢弃</p><p><strong>422：语义错误</strong></p><p><strong>500：服务器内部错误</strong> 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器端的源代码出现错误时出现。</p><p>501：服务器无法识别 服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。</p><p>502：错误网关 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</p><p>503：服务出错 由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。</p><p>TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复</p><h2 id="问-Cookie相关"><a href="#问-Cookie相关" class="headerlink" title="问: Cookie相关"></a>问: Cookie相关</h2><p>Cookie 存在客户端 Session 存在服务端<br>Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。<br>Cookie 一般用来保存用户信息 比如①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③登录一次网站后访问网站其他页面不需要重新登录。Session 的主要作用就是通过服务端记录用户的状态。 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。<br>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。<br>Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果使用 Cookie 的一些敏感信息不要写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p><p>使用 Session 维护用户登录状态的过程如下：</p><ol><li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li><li>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；</li><li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中（也可使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递）；</li><li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。<h2 id="问：GET与POST区别"><a href="#问：GET与POST区别" class="headerlink" title="问：GET与POST区别"></a>问：GET与POST区别</h2>GET 用于获取资源，而 POST 用于传输实体主体。（get类似select post类似update）<br>GET是幂等的</li></ol><h2 id="问：TCP"><a href="#问：TCP" class="headerlink" title="问：TCP"></a>问：TCP</h2><h3 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h3><p><strong>全双工的，所以两边的发送状态和接受状态都要完美的确认！</strong>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</p><h3 id="ARQ协议"><a href="#ARQ协议" class="headerlink" title="ARQ协议"></a>ARQ协议</h3><p>自动重传请求（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。<br><strong>连续的ARQ协议</strong><br>TCP 利用滑动窗口实现流量控制。<br>拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。<br>TCP的拥塞控制采用了四种算法，即 慢开始 、 拥塞避免 、快重传 和 快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。<br><a href="http://dl2.iteye.com/upload/attachment/0077/6058/5d4e8c89-fc42-3862-bdb8-399bc982f410.png" target="_blank" rel="noopener">http://dl2.iteye.com/upload/attachment/0077/6058/5d4e8c89-fc42-3862-bdb8-399bc982f410.png</a></p><p>链接：<a href="https://www.nowcoder.com/questionTerminal/0d07822c751c41ff865401d77c17364d?orderByHotValue=0&done=0&pos=13&onlyReference=false" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/0d07822c751c41ff865401d77c17364d?orderByHotValue=0&amp;done=0&amp;pos=13&amp;onlyReference=false</a><br>来源：牛客网</p><h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><h2 id="问-隔离级别"><a href="#问-隔离级别" class="headerlink" title="问:隔离级别"></a>问:隔离级别</h2><ul><li><strong>未提交读</strong>（READ UNCOMMITTED）</li></ul><p>事务中的修改，即使没有提交，对其它事务也是可见的。</p><ul><li><strong>提交读</strong>（READ COMMITTED）</li></ul><p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</p><ul><li><strong>可重复读</strong>（REPEATABLE READ）</li></ul><p>保证在同一个事务中多次读取同样数据的结果是一样的。</p><ul><li><strong>可串行化</strong>（SERIALIZABLE）</li></ul><p>强制事务串行执行。<br>需要加锁实现，而其它隔离级别通常不需要。</p><p><strong>不可重复读</strong>是针对于多次读取同一条数据出现不同结果，<strong>幻读</strong>是多次读取而产生的记录数不一样。</p><p>Atomicity：原子性，以事物transact为最小单位，事物中的所有操作，要么都执行完，要么都不执行，不存在一部分操作执行，另一部分操作不执行的情况。<br>Consistency：一致性，在事物开始和事物完成后，数据库的完整性限制不会改变。<br>Isolation：隔离性，同一个数据库中同时并发执行多个事务，事物之间的操作不会相互影响。<br>Durability：持久性，事物完成之后，事物所作的操作会持久存在于数据库中。<br>操作会持久存在于数据库中。</p><hr><p>| ** 隔离级别 **   | ** 脏读 **   | ** 不可重复读 **   | ** 幻影读 **   |<br>|:—-:|:—-:|:—-:|:—-:|:—-:|:—-:|:—-:|:—-:|<br>|  未提交读    |  √    |  √    |  √    |<br>|  提交读    |  ×    |  √    |  √    |<br>|  可重复读    |  ×    |  ×    |  √    |<br>|  可串行化    |  ×    |  ×    |  ×    |</p><h2 id="问：内连接-外连接-自然连接-组合连接"><a href="#问：内连接-外连接-自然连接-组合连接" class="headerlink" title="问：内连接 外连接 自然连接 组合连接"></a>问：内连接 外连接 自然连接 组合连接</h2><p>自然连接是把同名列通过等值测试连接起来的，同名列可以有多个。<br>内连接和自然连接的区别：内连接提供连接的列，而自然连接自动连接所有同名列。<br>外连接保留了没有关联的那些行。分为左外连接，右外连接以及全外连接，左外连接就是保留左表没有关联的行。<br>检索所有顾客的订单信息，包括还没有订单信息的顾客。<br>让选择性最强的索引列放在前面。<br>使用前缀索引</p><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="问：GC中如何判断对象是否需要被回收？"><a href="#问：GC中如何判断对象是否需要被回收？" class="headerlink" title="问：GC中如何判断对象是否需要被回收？"></a>问：GC中如何判断对象是否需要被回收？</h2><ol><li><strong>引用可达法</strong>，程序运行从开始，每次引用对象，都将对引用的对象进行连接起来，到最后形成一张网，没有在这张网上的对象则被认为是垃圾对象。</li><li><strong>引用计数法</strong>，对于对象的引用，每引用一次计数器加一，引用失败，计数器减一，当计数器一段时间为0，则可以被认为是垃圾。</li></ol><h2 id="问：new-一个对象的过程："><a href="#问：new-一个对象的过程：" class="headerlink" title="问：new 一个对象的过程："></a>问：new 一个对象的过程：</h2><p>Java在new一个对象的时候，会先查看对象所属的类有没有被加载到内存，如果没有的话，就会先通过类的全限定名来加载。加载并初始化类完成后，再进行对象的创建工作。</p><p>我们先假设是第一次使用该类，这样的话new一个对象就可以分为两个过程：加载并初始化类和创建对象。<br>总结下来就是：</p><ol><li><strong>类加载检查</strong></li><li><strong>分配内存</strong></li><li><strong>初始化零值</strong></li><li><strong>设置对象头</strong></li><li><strong>执行init方法</strong></li></ol><p>详情见JavaGuide的Java内存区域</p><ol><li>*<em>类加载机制 *</em><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.md" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.md</a></li></ol><p><strong>1、加载</strong><br>     由类加载器负责根据一个类的全限定名来读取此类的二进制字节流到JVM内部，并存储在运行时内存区的方法区，然后将其转换为一个与目标类型对应的java.lang.Class对象实例<br>2、验证<br>格式验证：验证是否符合class文件规范<br>语义验证：检查一个被标记为final的类型是否包含子类；检查一个类中的final方法是否被子类进行重写；确保父类和子类之间没有不兼容的一些方法声明（比如方法签名相同，但方法的返回值不同）<br>操作验证：在操作数栈中的数据必须进行正确的操作，对常量池中的各种符号引用执行验证（通常在解析阶段执行，检查是否可以通过符号引用中描述的全限定名定位到指定类型上，以及类成员信息的访问修饰符是否允许访问等）<br>3、准备<br>为类中的所有静态变量分配内存空间，并为其设置一个初始值（由于还没有产生对象，实例变量不在此操作范围内）<br>被final修饰的static变量（常量），会直接赋值；<br>4、解析<br>将常量池中的符号引用转为直接引用（得到类或者字段、方法在内存中的指针或者偏移量，以便直接调用该方法），这个可以在初始化之后再执行。<br>解析需要静态绑定的内容。  // 所有不会被重写的方法和域都会被静态绑定<br>  <strong>以上2、3、4三个阶段又合称为链接阶段</strong>，链接阶段要做的是将加载到JVM中的二进制字节流的类数据信息合并到JVM的运行时状态中。<br>5、初始化（先父后子）<br>4.1 为静态变量赋值<br>4.2 执行static代码块<br>因为子类存在对父类的依赖，所以<strong>类的加载顺序是先加载父类后加载子类，初始化也一样。</strong>不过，父类初始化时，子类静态变量的值也有有的，是默认值。<br>最终，方法区会存储当前类类信息，包括类的<strong>静态变量</strong>、<strong>类初始化代码</strong>（<strong>定义静态变量时的赋值语句 *<em>和 *</em>静态初始化代码块</strong>）、<strong>实例变量定义</strong>、<strong>实例初始化代码</strong>（<strong>定义实例变量时的赋值语句实例代码块</strong>和<strong>构造方法</strong>）和<strong>实例方法</strong>，还有<strong>父类的类信息引用。</strong></p><ol start="2"><li><strong>创建对象</strong></li></ol><p><strong>1、在堆区分配对象需要的内存</strong><br>  分配的内存包括本类和父类的所有实例变量，但不包括任何静态变量<br><strong>2、对所有实例变量赋默认值</strong><br>  将方法区内对实例变量的定义拷贝一份到堆区，然后赋默认值<br><strong>3、执行实例初始化代码</strong><br>  初始化顺序是先初始化父类再初始化子类，初始化时先执行实例代码块然后是构造方法<br><strong>4、如果有类似于Child c = new Child()形式的c引用的话，在栈区定义Child类型引用变量c，然后将堆区对象的地址赋值给它</strong></p><h2 id="问：垃圾收集算法"><a href="#问：垃圾收集算法" class="headerlink" title="问：垃圾收集算法"></a>问：垃圾收集算法</h2><p>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。<br>一般将堆分为新生代和老年代。<br><strong>新生代使用：复制算法</strong><br><strong>老年代使用：标记 - 清除 或者 标记 - 整理 算法</strong></p><p>一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。</p><p>HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。</p><h2 id="问：垃圾回收器，优缺点"><a href="#问：垃圾回收器，优缺点" class="headerlink" title="问：垃圾回收器，优缺点"></a><strong>问：垃圾回收器，优缺点</strong></h2><p><strong>串行垃圾回收</strong>是最简单的也是效率最低的，如果只是控制台的单线程程序，简单任务，并且机器配置不高，推荐使用。** **新生代采用复制算法，老年代采用标记-整理算法</p><p><strong>并行垃圾回收器</strong>是64bit server默认的垃圾回收器，一般我们工作和生产上默认不配置，都是并行垃圾回收。对于一般的不要求吞吐的应用，并且硬件资源不是太充足的情况下，并行垃圾回收器差不多能满足需求。新生代采用复制算法，老年代采用标记-整理算法。** **</p><p><strong>CMS垃圾回收器</strong>CMS在应用不停顿的情况下使用独立的线程进行垃圾回收，在每个老年代回收周期中需要短暂停顿两次，初始标记阶段和重新标记阶段。其他时间并发标记，并发清理。** <strong>**并发收集、低停顿。</strong>标记-清除算法</p><p><strong>G1垃圾回收器</strong>是针对于大heap的垃圾回收器，如果heap分配的足够大，分的region的优先级回收策略会优先清理垃圾多的region.并且减少了内存空间碎片，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。</p><h1 id="Concurrent"><a href="#Concurrent" class="headerlink" title="Concurrent"></a>Concurrent</h1><h2 id="问：volatile关键字"><a href="#问：volatile关键字" class="headerlink" title="问：volatile关键字"></a>问：volatile关键字</h2><p>Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。</p><h2 id="问：多线程中的i-线程安全吗？为什么？"><a href="#问：多线程中的i-线程安全吗？为什么？" class="headerlink" title="问：多线程中的i++线程安全吗？为什么？"></a>问：多线程中的i++线程安全吗？为什么？</h2><p>不安全。i++不是原子性操作。i++分为读取i值，对i值加一，再赋值给i++，执行期中任何一步都是有可能被其他线程抢占的。</p><h1 id="问：Java并发工具类"><a href="#问：Java并发工具类" class="headerlink" title="问：Java并发工具类"></a>问：Java并发工具类</h1><p>与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。</p><p>Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。<br>主要有三种 Executor：</p><ul><li>CachedThreadPool：一个任务创建一个线程；</li><li>FixedThreadPool：所有任务只能使用固定大小的线程；</li><li>SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。</li><li>public static void main(String[] args) {<br>   ExecutorService executorService = Executors.newCachedThreadPool();<br>   for (int i = 0; i &lt; 5; i++) {<pre><code>executorService.execute(new MyRunnable());</code></pre>   }<br>   executorService.shutdown();<br>}</li></ul><p>主要有两类<br>①并发流程控制相关：CountDownLatch、CyclicBarrier、Semaphore<br>②线程间交换数据相关：Exchanger；</p><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><ul><li>作用：允许一个或多个线程等待其他线程完成操作</li><li>使用步骤：<br>①定义一个CountDownLatch（称为计数器），并指定等待次数；<br>②在合适的时机将计数器减1；<br>③在需要等待所有任务结束的位置，调用await()方法；</li></ul><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><ul><li>作用：让一组线程等待至某个状态之后再全部同时执行，适用于多线程计算数据，最后合并计算结果的场景。<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3></li><li>作用：控制同时访问特定资源的线程数量，进行流量控制</li><li>使用：①创建Semaphore，根据资源特性，指定可以同时访问该资源的线程数量；②在具体使用资源的时候，首先从Semaphore获取许可证，使用完资源之后，释放资源</li><li>值得注意的是：在一个线程release之前，并不一定要acquire。可以根据程序需要，自行控制。</li></ul><ol><li>锁的实现</li></ol><p>synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</p><ol start="2"><li>性能</li></ol><p>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。</p><ol start="3"><li>等待可中断</li></ol><p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。<br>ReentrantLock 可中断，而 synchronized 不行。</p><ol start="4"><li>公平锁</li></ol><p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。<br>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</p><ol start="5"><li>锁绑定多个条件</li></ol><p>一个 ReentrantLock 可以同时绑定多个 Condition 对象。</p><h1 id="海量数据"><a href="#海量数据" class="headerlink" title="海量数据"></a><strong>海量数据</strong></h1><h2 id="问"><a href="#问" class="headerlink" title="问"></a>问</h2><p><a href="https://blog.csdn.net/v_july_v/article/details/6685962" target="_blank" rel="noopener">https://blog.csdn.net/v_july_v/article/details/6685962</a><br><a href="https://blog.csdn.net/v_july_v/article/details/7382693#comments" target="_blank" rel="noopener">https://blog.csdn.net/v_july_v/article/details/7382693#comments</a><br>Bloom Filter使用了k个哈希函数，每个字符串跟k个bit对应。从而降低了冲突的概率</p><h2 id="问：长地址转换"><a href="#问：长地址转换" class="headerlink" title="问：长地址转换"></a>问：长地址转换</h2><p>短url映射长url，系统qps5000，要求设计一套完整的高可用分布式系统，设计数据库结构，负载均衡等，且要求可以1s内查询到出现次数前100的Url。<br>全局自增id做可逆哈希，lru缓存常用的，其他的用数据库</p><h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h2 id="问：NIO"><a href="#问：NIO" class="headerlink" title="问：NIO"></a>问：NIO</h2><p>一个输入操作通常包括两个阶段：</p><ul><li>等待数据准备好</li><li>从内核向进程复制数据</li></ul><p>系统调用就是应用程序与系统内核之间的接口。通过系统调用访问系统资源。<br>Unix 有五种 I/O 模型：</p><ul><li>阻塞式 I/O</li><li>非阻塞式 I/O</li><li>I/O 复用（select 和 poll）</li><li>信号驱动式 I/O（SIGIO）</li><li>异步 I/O（AIO）</li></ul><p><strong>应用进程被阻塞，而不是系统所有线程被阻塞。</strong><br>当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。<br>select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。</p><p>很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。</p><p>###</p><h3 id="1-select-应用场景"><a href="#1-select-应用场景" class="headerlink" title="1. select 应用场景"></a>1. select 应用场景</h3><p>select 的 timeout 参数精度为 1ns，而 poll 和 epoll 为 1ms，因此 select 更加适用于实时性要求比较高的场景，比如核反应堆的控制。<br>select 可移植性更好，几乎被所有主流平台所支持。</p><p>###</p><h3 id="2-poll-应用场景"><a href="#2-poll-应用场景" class="headerlink" title="2. poll 应用场景"></a>2. poll 应用场景</h3><p>poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。</p><p>###</p><h3 id="3-epoll-应用场景"><a href="#3-epoll-应用场景" class="headerlink" title="3. epoll 应用场景"></a>3. epoll 应用场景</h3><p>只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。<br>需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。<br>需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且 epoll 的描述符存储在内核，不容易调试。</p><ul><li>NIO 是非阻塞的；</li><li>NIO 面向块，I/O 面向流。</li></ul><p>NIO 常常被叫做非阻塞 IO，主要是因为 NIO 在网络通信中的非阻塞特性被广泛使用。</p><p>NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。</p><p>通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。</p><p>因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件，对于 IO 密集型的应用具有很好地性能。</p><p>应该注意的是，只有套接字 Channel 才能配置为非阻塞，而 FileChannel 不能，为 FileChannel 配置非阻塞也没有意义。</p><h1 id="Design-Pattern"><a href="#Design-Pattern" class="headerlink" title="Design Pattern"></a>Design Pattern</h1><p>创建型</p><ul><li>单例模式 <a href="https://blog.csdn.net/qq_34337272/article/details/80455972" target="_blank" rel="noopener">https://blog.csdn.net/qq_34337272/article/details/80455972</a></li></ul><p>设计模式那么多种，推荐熟悉以下几种就可以：单例、代理模式、工厂（三种）、适配器、装饰器、策略、观察者等</p><p><strong>观察者模式，</strong>又称发布订阅模式。对象状态发生变化时，所有依赖它的对象都会收到通知并且自动更新自己。秒杀业务里面的秒杀按钮倒计时自动更新就是观察者模式。<br><strong>装饰模式：（主要应用场景就是输入输出流）</strong><br>  在不改变接口的前提下，动态扩展对象的访问。<br>  动态继承，让类具有在运行期改变行为的能力。<br>  装饰模式，突出的是运行期增加行为，这和继承是不同的，继承是在编译期增加行为。<br><strong>强调：增强，新增行为</strong><br><strong>代理模式：</strong><br>  在不改变接口的前提下，控制对象的访问。<br>  1.从封装的角度讲，是为了解决类与类之间相互调用而由此导致的耦合关系，可以说是接口的另外一个层引用。<br>    比如：在a类-&gt;b代理-&gt;c类这个关系中，c类的一切行为都隐藏在b中。即调用者不知道要访问的内容与代理了什么对象。<br>  2.从复用的角度讲，可以解决不同类调用一个复杂类时，仅仅因较小的改变而导致整个复杂类新建一个类。<br>    比如：a类-&gt;c类1；b类-&gt;c类2。<br>    可以变为a类-&gt;ca代理类-&gt;c类；b类-&gt;cb代理类-c类。<br>  代理模式，是类之间的封装和（某方面的）复用。<br>  <strong>强调：限制，控制访问</strong></p><p><strong>策略**</strong>模式**是对算法的包装，是把使用算法的责任和算法本身分割开来，委派给不同的对象管理。策略模式通常把一个系列的算法包装到一系列的策略类里面，作为一个抽象策略类的子类。用一句话来说，就是：“准备一组算法，并将每一个算法封装起来，使得它们可以互换”。 下面就以一个示意性的实现讲解策略模式实例的结构。<br>应用场景：Comparator 外部比较器接口</p><p>饿汉型（非动态），懒汉型，双重检查懒汉型，内部静态类方法（懒），枚举方法（饿），<br>行为型</p><ul><li>命令模式 相当于有一个遥控 解耦命令的发送者和命令的接收者<br>命令模式： <a href="https://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/command.html" target="_blank" rel="noopener">https://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/command.html</a> 在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计，使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活。命令模式可以对发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。这就是命令模式的模式动机。</li><li>中介者模式 Spring MVC 里面的C</li><li>备忘录模式 以下实现了一个简单计算器程序，可以输入两个值，然后计算这两个值的和。备忘录模式允许将这两个值存储起来，然后在某个时刻用存储的状态进行恢复。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private static class SingletonHolder &#123;  </span><br><span class="line">    private static final Singleton INSTANCE = new Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">    public static final Singleton getInstance() &#123;  </span><br><span class="line">    return SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    //volatile保证，当uniqueInstance变量被初始化成Singleton实例时，多个线程可以正确处理uniqueInstance变量</span><br><span class="line">    private volatile static Singleton uniqueInstance;</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">       //检查实例，如果不存在，就进入同步代码块</span><br><span class="line">        if (uniqueInstance == null) &#123;</span><br><span class="line">            //只有第一次才彻底执行这里的代码</span><br><span class="line">            synchronized(Singleton.class) &#123;</span><br><span class="line">               //进入同步代码块后，再检查一次，如果仍是null，才创建实例</span><br><span class="line">                if (uniqueInstance == null) &#123;</span><br><span class="line">                    uniqueInstance = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构型</p><ul><li>适配器模式 把一个类的接口转换成另一个用户需要的接口</li><li>桥接模式 将抽象和显示分离开，使它们可以独立变化。</li><li>组合模式</li><li>装饰模式 为对象动态添加功能 类似于继承 但是更加灵活</li><li>外观模式 ,他隐藏了系统的复杂性，并向客户端提供了一个可以访问系统的接口。这种类型的设计模式属于结构性模式。为子系统中的一组接口提供了一个统一的访问接口，这个接口使得子系统更容易被访问或者使用</li><li>代理模式 Spring AOP 是对JDK动态代理的经典应用</li><li>远程代理 虚拟代理 安全代理 指针引用 延迟加载</li></ul><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><p><a href="https://www.cnblogs.com/rrttp/p/8715731.html" target="_blank" rel="noopener">https://www.cnblogs.com/rrttp/p/8715731.html</a></p><h3 id="算法相关"><a href="#算法相关" class="headerlink" title="算法相关"></a>算法相关</h3><p>希尔排序 改进的插入排序<br>并查集算法 find join<br>前缀树 可以最大限度地减少无谓的字符串比较，故可以用于词频统计和大量字符串排序。</p><p>抽象类就是被继承的 所以不能实例化</p><p> cat 文件内容查看、find 搜索文件，以及 cut、sort 等管线命令。了解 grep 和 awk 的作用。</p><h1 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h1><h2 id="问：线程间的几种通信方式知道不？"><a href="#问：线程间的几种通信方式知道不？" class="headerlink" title="问：线程间的几种通信方式知道不？"></a><strong>问：线程间的几种通信方式知道不？</strong></h2><p>线程间通信的主要目的是用于线程同步，所以线程没有象进程通信中用于数据交换的通信机制。</p><h2 id="问：进程间的几种通信方式说一下？"><a href="#问：进程间的几种通信方式说一下？" class="headerlink" title="问：进程间的几种通信方式说一下？"></a><strong>问：进程间的几种通信方式说一下？</strong></h2><ol><li>管道（pipe）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有血缘关系的进程间使用。进程的血缘关系通常指父子进程关系。管道分为pipe（无名管道）和fifo（命名管道）两种，有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间通信。</li><li>信号量（semophore）：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它通常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li><li>消息队列（message queue）：消息队列是由消息组成的链表，存放在内核中 并由消息队列标识符标识。消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。消息队列与管道通信相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息。</li><li>信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某一事件已经发生。</li><li>共享内存（shared memory）：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问，共享内存是最快的IPC方式，它是针对其他进程间的通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。</li><li>套接字（socket）：socket，即套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。也因为这样，套接字明确地将客户端和服务器区分开来。</li></ol><p>Java基本数据类型传递参数时是值传递；引用类型传递参数时是引用传递。</p><h2 id="问：操作系统五种调度技术"><a href="#问：操作系统五种调度技术" class="headerlink" title="问：操作系统五种调度技术"></a>问：操作系统五种调度技术</h2><p><a href="https://blog.csdn.net/xieminyao123/article/details/79116985" target="_blank" rel="noopener">https://blog.csdn.net/xieminyao123/article/details/79116985</a><br>周转时间=完成时间-到达时间<br><strong>带权周转时间=周转时间/服务时间</strong></p><ol><li><p>先到先服务（非抢占式）</p></li><li><p>最短进程优先（非抢占式）</p></li><li><p>最短剩余时间优先（抢占式）</p></li><li><p>时间片轮转调度算法 （抢占式）</p></li><li><p>高相应比优先（非抢占）</p></li><li><p>锁的实现</p></li></ol><p>synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</p><ol start="2"><li>性能</li></ol><p>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。</p><ol start="3"><li>等待可中断</li></ol><p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。<br>ReentrantLock 可中断，而 synchronized 不行。</p><ol start="4"><li>公平锁</li></ol><p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。<br>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</p><ol start="5"><li>锁绑定多个条件</li></ol><p>一个 ReentrantLock 可以同时绑定多个 Condition 对象。</p><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p> AQS是AbstractQueuedSynchronizer的简称。AQS提供了一种实现阻塞锁和一系列依赖FIFO等待队列的同步器的框架<br>AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。</p><ul><li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</li><li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li><li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li><li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li><li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li></ul><p>Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。</p><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是：比较并交换（Compare-and-Swap，CAS）。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。</p><p>回溯法跳出循环的地方用 return；</p><p>六大原则<br>单一职责原则<br>里氏替换原则<br>依赖倒置原则<br>接口隔离原则<br>迪米特原则<br>开闭原则<br><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.md" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.md</a></p><hr><p>JDBC 桥接模式</p><h2 id="TCP-为什么三次握手而不是两次握"><a href="#TCP-为什么三次握手而不是两次握" class="headerlink" title="TCP 为什么三次握手而不是两次握"></a>TCP 为什么三次握手而不是两次握</h2><p>为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤<br>双方都发SYN和ACK<br>如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认</p><p>ORM(Object Relation Mapping), 表对类, 数据对对象, 字段对属性</p><h2 id="为什么非静态内部类不能定义静态方法-静态成员-静态初始化块"><a href="#为什么非静态内部类不能定义静态方法-静态成员-静态初始化块" class="headerlink" title="为什么非静态内部类不能定义静态方法, 静态成员, 静态初始化块?"></a>为什么非静态内部类不能定义静态方法, 静态成员, 静态初始化块?</h2><p>因为静态方法属于类, 如果调用一个静态方法需要提前实例化一个对象, 那么久违背了该准则.</p><h2 id="！-动态代理的几种实现方式-优缺点-可以通过类实现吗"><a href="#！-动态代理的几种实现方式-优缺点-可以通过类实现吗" class="headerlink" title="！ 动态代理的几种实现方式? 优缺点? 可以通过类实现吗?"></a>！ 动态代理的几种实现方式? 优缺点? 可以通过类实现吗?</h2><p>JDK: 通过接口, invocationHandler cglib: 通过继承(子类可以继承父类私有方法与属性, 只是子类无法直接访问私有方法; 不能继承final修饰的方法), 速度较快.</p><h2 id="try-catch-finally执行过程-finally是不是一定会执行"><a href="#try-catch-finally执行过程-finally是不是一定会执行" class="headerlink" title="try-catch-finally执行过程? finally是不是一定会执行?"></a>try-catch-finally执行过程? finally是不是一定会执行?</h2><p>执行过程: 先执行try,如果有异常则被catch捕获, 最后执行finally.finally一定会被执行, 即使try中有return语句, 并且如果finally中也有return语句, 则会返回finally中的return语句.</p><h2 id="Java类什么时候加载"><a href="#Java类什么时候加载" class="headerlink" title="Java类什么时候加载?"></a>Java类什么时候加载?</h2><ul><li>实例通过使用new()关键字创建或者使用class.forName()反射, 但它有可能导致ClassNotFoundException.</li><li>类的静态方法被调用</li><li>类的静态域被赋值</li><li>静态域被访问, 而且它不是常量</li><li>在顶层类中执行assert语句</li></ul><p><a href="https://img-blog.csdn.net/20171101213339213?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamluOTcwNTA1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" target="_blank" rel="noopener">https://img-blog.csdn.net/20171101213339213?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamluOTcwNTA1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center</a></p><h2 id="！类加载过程-机制-有什么优势-类加载器有哪些"><a href="#！类加载过程-机制-有什么优势-类加载器有哪些" class="headerlink" title="！类加载过程, 机制? 有什么优势? 类加载器有哪些?"></a>！类加载过程, 机制? 有什么优势? 类加载器有哪些?</h2><p>过程: 加载-链接-初始化 机制: 双亲委托加载 优势: 保证核心API, 避免重复加载 类加载器: BootStrap ClassLoader, Extention ClassLoader, App ClassLoader, Custom ClassLoader<br>双亲委托机制：当某个特定的类加载器在接收到加载类的请求时，首先将该加载任务发送给父类加载器，若父类加载器仍有父类，则继续向上追溯，直到最高级。<br>         如果最高级父类能够加载到该类，则成功返回，否则由其子类进行加载。以此类推，如果到最后一个子类还不能成功加载，则抛出一个异常。</p><h2 id="被static或transient修饰的属性能被序列化吗"><a href="#被static或transient修饰的属性能被序列化吗" class="headerlink" title="被static或transient修饰的属性能被序列化吗?"></a>被static或transient修饰的属性能被序列化吗?</h2><p>这两种修饰的属性不能被序列化</p><h2 id="！Java中socket连接过程"><a href="#！Java中socket连接过程" class="headerlink" title="！Java中socket连接过程?"></a>！Java中socket连接过程?</h2><p>服务器: bind, listen, accept, connect, write/read, close 客户端: connect, write/read, close</p><h2 id="！Java中的引用有哪些类型-目的是什么-使用软引用能够带来什么好处"><a href="#！Java中的引用有哪些类型-目的是什么-使用软引用能够带来什么好处" class="headerlink" title="！Java中的引用有哪些类型? 目的是什么? 使用软引用能够带来什么好处?"></a>！Java中的引用有哪些类型? 目的是什么? 使用软引用能够带来什么好处?</h2><ul><li>强: 一般对象引用</li><li>软: 只有当内存不足时才会对失去引用的对象进行回收</li><li>弱: 一旦失去最后一个强引用, 立即回收</li><li>虚: 用来跟踪对象被垃圾回收的活动, 虚引用必须和引用队列(ReferenceQueue)联合使用.程序可以通过判断引用队列中是 否已经加入了虚引用, 来了解被引用的对象是否将要被垃圾回收.程序如果发现某个虚引用已经被加入到引用队列, 那么就可以在所引用的对象的内存被回收之前采取必要的行动.<a href="https://www.cnblogs.com/javaee6/p/4763190.html" target="_blank" rel="noopener">参考</a></li><li>目的: 以代码的形式管理对象生命周期</li></ul><p>软引用好处: 提升JVM内存使用性能</p><h2 id="throw和throws的区别"><a href="#throw和throws的区别" class="headerlink" title="throw和throws的区别?"></a>throw和throws的区别?</h2><p>前者抛出一个具体异常; 后者只是声明可能会抛出的异常不一定会抛出</p><h2 id="处理完异常后-Exception会有什么变化"><a href="#处理完异常后-Exception会有什么变化" class="headerlink" title="处理完异常后, Exception会有什么变化?"></a>处理完异常后, Exception会有什么变化?</h2><p>会在下一个垃圾回收过程中被回收</p><h2 id="Java中用什么数据类型来代表价格"><a href="#Java中用什么数据类型来代表价格" class="headerlink" title="Java中用什么数据类型来代表价格?"></a>Java中用什么数据类型来代表价格?</h2><p>BigDecimal, 需要使用字符串初始化, 用double初始化仍然不能精确表示</p><h2 id="final-finally-finalize的区别"><a href="#final-finally-finalize的区别" class="headerlink" title="final, finally, finalize的区别?"></a>final, finally, finalize的区别?</h2><ul><li>final修饰类, 类不可以被继承; 修饰方法, 方法不可以被重写; 修饰变量, 基本类型的值不可以改变, 引用类型不能改变其引用</li><li>finally:try中使用, 而且一定会执行</li><li>finalize: object方法, 重写后给变量一个自救机会, 让其与root链上的对象进行关联（当对象不再被任何对象引用时，GC会调用该对象的finalize()方法）<h2 id="类初始化过程"><a href="#类初始化过程" class="headerlink" title="类初始化过程?"></a>类初始化过程?</h2>父类静态成员、父类静态代码块-子类静态成员、子类静态代码块-父类普通成员、父类代码块、父类构造函数-子类普通成员、子类代码块、子类构造函数</li></ul><h2 id="数组和列表有什么区别-如何选择"><a href="#数组和列表有什么区别-如何选择" class="headerlink" title="数组和列表有什么区别? 如何选择"></a>数组和列表有什么区别? 如何选择</h2><p>数组:</p><ul><li>可以存储基本类型与对象类型</li><li>不可扩展</li><li>提供的方法较少</li></ul><p>列表:</p><ul><li>不能存储基本类型, 只能存储对象类型</li><li>可以扩展</li><li>提供方法较多</li></ul><p>选择: 看具体情况, 追求性能的话选用数组, 追求可扩展性的话选择列表</p><h2 id="ArrayList与LinkedList区别-底层原理-ArrayList扩容、删除如何实现"><a href="#ArrayList与LinkedList区别-底层原理-ArrayList扩容、删除如何实现" class="headerlink" title="ArrayList与LinkedList区别? 底层原理? ArrayList扩容、删除如何实现?"></a>ArrayList与LinkedList区别? 底层原理? ArrayList扩容、删除如何实现?</h2><p>前者底层数组, 后者底层使用链表<br>ArrayList初始大小默认为10(可以指定), 之后每次扩展1.5倍, 扩容使用Arrays.copyOf()进行迁移<br>删除之后使用System.arraycopy()将之后的数据往前移动</p><p>hashmap 拉链法 数组加链表</p><h2 id="线程调用过程"><a href="#线程调用过程" class="headerlink" title="线程调用过程?"></a>线程调用过程?</h2><p>线程调用start()之后使得线程进入资源竞争状态, 当线程获取时间片后调用线程的run()方法<br>线程状态转移图<br><a href="http://static.oschina.net/uploads/space/2013/0621/174442_0BNr_182175.jpg" target="_blank" rel="noopener">http://static.oschina.net/uploads/space/2013/0621/174442_0BNr_182175.jpg</a><br>线程状态: 创建, 可运行, 运行, 阻塞(等待阻塞(wait)与一般阻塞(sleep, System.in)), 结束</p><h2 id="你对线程优先级的理解"><a href="#你对线程优先级的理解" class="headerlink" title="你对线程优先级的理解?"></a>你对线程优先级的理解?</h2><p>线程优先级也就是公平锁和非公平锁的实现, 线程优先级高的线程不一定能够比优先级低的线程先抢夺到资源.</p><h2 id="synchronized与Lock比较-锁与同步锁的比较"><a href="#synchronized与Lock比较-锁与同步锁的比较" class="headerlink" title="synchronized与Lock比较(锁与同步锁的比较)?"></a>synchronized与Lock比较(锁与同步锁的比较)?</h2><ol><li>底层实现 synchronized由JVM实现, Lock由JDK实现</li><li>性能 JDK1.6开始对synchronized进行优化后性能提升, 如果不需要使用Lock的高级功能, 一般使用synchronized</li><li>功能 Lock功能比synchronized多, 可以绑定多个条件</li><li>显示与隐式 synchronized不需要手动释放锁, Lock需要手动释放锁</li><li>中断其它阻塞线程 synchronized不能中断其他正在等待的阻塞线程, 而Lock可以<h2 id="介绍一下AQS"><a href="#介绍一下AQS" class="headerlink" title="介绍一下AQS?"></a>介绍一下AQS?</h2>Abstract Queue Synchronizer, 维护一个同步状态和一个FIFO线程等待队列 定义了两种资源共享方式:</li></ol><ul><li>独占锁</li><li>共享锁<h2 id="说说-synchronized-关键字和-volatile-关键字的区别"><a href="#说说-synchronized-关键字和-volatile-关键字的区别" class="headerlink" title="说说 synchronized 关键字和 volatile 关键字的区别"></a>说说 synchronized 关键字和 volatile 关键字的区别</h2></li></ul><ol><li>s修饰方法和代码块, v修饰变量; s性能略差与v</li><li>s实现原子性和可见性, v实现可见性</li><li>v不发生阻塞, s发生阻塞</li><li>s解决多线程资源同步问题, v解决多线程下可见性</li></ol><h2 id="CAS机制-包含哪些操作-会产生哪些问题-如何避免ABA问题"><a href="#CAS机制-包含哪些操作-会产生哪些问题-如何避免ABA问题" class="headerlink" title="CAS机制? 包含哪些操作? 会产生哪些问题? 如何避免ABA问题?"></a>CAS机制? 包含哪些操作? 会产生哪些问题? 如何避免ABA问题?</h2><p>机制: V(内存位置)A(预期值)B(新值), 仅当V符合预期值A时, 处理器才会用B更新V的值, 否则不会执行更新操作. 缺点:</p><ul><li>只能对单个变量进行操作</li><li>循环等待时间长</li><li>ABA问题.解决办法: 时间戳<h2 id="Thread中join-方法的原理"><a href="#Thread中join-方法的原理" class="headerlink" title="Thread中join()方法的原理?"></a>Thread中join()方法的原理?</h2>阻塞主线程, 等待子线程结束后调用notify方法唤醒主线程</li></ul><h2 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别?"></a>sleep和wait的区别?</h2><ul><li>sleep不释放资源, wait会释放资源</li><li>sleep在指定时间之后会参与资源竞争; wait需要notify之后才能去竞争<h2 id="FutureTask是什么"><a href="#FutureTask是什么" class="headerlink" title="FutureTask是什么?"></a>FutureTask是什么?</h2></li><li>线程执行任务</li><li>异步获取执行结果</li></ul><p>singleThreadExcutor</p><h2 id="各种排序算法时间复杂度与空间复杂度比较-冒泡、交换、选择、插入、基数、希尔、快排、归并、堆"><a href="#各种排序算法时间复杂度与空间复杂度比较-冒泡、交换、选择、插入、基数、希尔、快排、归并、堆" class="headerlink" title="各种排序算法时间复杂度与空间复杂度比较? 冒泡、交换、选择、插入、基数、希尔、快排、归并、堆"></a>各种排序算法时间复杂度与空间复杂度比较? 冒泡、交换、选择、插入、基数、希尔、快排、归并、堆</h2><p>排序方法-时间复杂度-最差时间-稳定性-额外空间</p><ul><li>冒泡-O(N^2)-O(N^2)-稳定-O(1)</li><li>交换-O(N^2)-O(N^2)-不稳定-O(1)</li><li>选择-O(N^2)-O(N^2)-不稳定-O(1)</li><li>插入-O(N^2)-O(N^2)-稳定-O(1)</li><li>基数-O(N)-O(N)-稳定-O(N)</li><li>希尔-O(NlogN)-O(N^2)-不稳定-O(1)</li><li>快排-O(NlogN)-O(N^2)-不稳定-O(logN)[最差O(N)]</li><li>归并-O(NlogN)-O(NlogN)-稳定-O(N)</li><li>堆-O(NlogN)-O(NlogN)-不稳定-O(1)<h2 id="JVM内存模型-介绍下-Java-内存区域-运行时数据区-程序计数器-栈-堆-方法区"><a href="#JVM内存模型-介绍下-Java-内存区域-运行时数据区-程序计数器-栈-堆-方法区" class="headerlink" title="JVM内存模型(介绍下 Java 内存区域/运行时数据区)? 程序计数器, 栈, 堆, 方法区?"></a>JVM内存模型(介绍下 Java 内存区域/运行时数据区)? 程序计数器, 栈, 堆, 方法区?</h2></li><li>程序计数器: 记录指令执行位置</li><li>栈: 存放已知基本类型数据以及对象指针</li><li>堆: 数组与对象, 垃圾回收主要区域</li><li>方法区: 类的信息, 常量, 静态变量<h2 id="Java基本类型、引用类型在内存中的存储原理"><a href="#Java基本类型、引用类型在内存中的存储原理" class="headerlink" title="Java基本类型、引用类型在内存中的存储原理?"></a>Java基本类型、引用类型在内存中的存储原理?</h2>基本类型存储在栈中, 引用类型的引用存储在栈中, 实例对象在堆中<h2 id="分析-Object-obj-new-Object-对象创建过程"><a href="#分析-Object-obj-new-Object-对象创建过程" class="headerlink" title="分析 Object obj = new Object(); 对象创建过程?"></a>分析 Object obj = new Object(); 对象创建过程?</h2>通过new创建一个对象, 对象存放在堆中, obj变量放在栈中指向堆中的对象.<h2 id="String-intern"><a href="#String-intern" class="headerlink" title="String.intern()?"></a>String.intern()?</h2>若字符串常量池中国已有该字符串则直接返回.JDK1.6及之前的字符串常量池在方法区, 之后的在堆中.<h2 id="CMS特点"><a href="#CMS特点" class="headerlink" title="CMS特点?"></a>CMS特点?</h2></li><li>CMS: 最短回收停顿时间为目标的收集器.初始标记(STW)-并发标记-重新标记(STW)-并发回收.在并发标记时会产生浮动垃圾, 并且需要在内存用尽完之前回收。<h2 id="内存模型三大特性-原子性、可见性、有序性如何实现"><a href="#内存模型三大特性-原子性、可见性、有序性如何实现" class="headerlink" title="内存模型三大特性? 原子性、可见性、有序性如何实现?"></a>内存模型三大特性? 原子性、可见性、有序性如何实现?</h2></li><li>原子性: synchronized实现</li><li>可见性: volatile即可实现, synchronized也可以实现</li><li>有序性: volatile, synchronized<h2 id="GC-Roots包含哪些"><a href="#GC-Roots包含哪些" class="headerlink" title="GC Roots包含哪些?"></a>GC Roots包含哪些?</h2></li><li>栈中的引用对象</li><li>本地方法中的引用对象</li><li>方法区指向对象的常量<h2 id="什么时候新生代会发生GC-老年代发生GC条件-Full-GC-触发条件"><a href="#什么时候新生代会发生GC-老年代发生GC条件-Full-GC-触发条件" class="headerlink" title="什么时候新生代会发生GC? 老年代发生GC条件? Full GC 触发条件?"></a>什么时候新生代会发生GC? 老年代发生GC条件? Full GC 触发条件?</h2></li><li>当Edien区域满了会发生Major gc</li><li>老年代满了会发生full gc</li></ul><p>full gc出触发条件:</p><ul><li>老年代满</li><li>空间分配担保失败</li><li>CMS抛出异常需要full gc</li><li>调用System.gc()命令<h2 id="对象创建的过程"><a href="#对象创建的过程" class="headerlink" title="对象创建的过程?"></a>对象创建的过程?</h2></li><li>类加载</li><li>申请空间, 指针碰撞法和空闲列表法</li><li>初始化地址空间</li><li>初始化类<h2 id="双重校验锁为什么要加锁后再次判断是否为空-为什么外面还要判断"><a href="#双重校验锁为什么要加锁后再次判断是否为空-为什么外面还要判断" class="headerlink" title="双重校验锁为什么要加锁后再次判断是否为空? 为什么外面还要判断?"></a>双重校验锁为什么要加锁后再次判断是否为空? 为什么外面还要判断?</h2>为防止加锁时其它线程刚好创建一个实例<br>外面判断的原因是为了提高性能, 因为并不是每次都需要加锁来创建对象<h2 id="常见HTTP状态码-100-200-301-302-400-401-403-404-500-502-503-504"><a href="#常见HTTP状态码-100-200-301-302-400-401-403-404-500-502-503-504" class="headerlink" title="常见HTTP状态码: 100, 200, 301, 302, 400, 401, 403, 404, 500, 502, 503, 504"></a>常见HTTP状态码: 100, 200, 301, 302, 400, 401, 403, 404, 500, 502, 503, 504</h2></li><li>100: 消息</li><li>200: 成功消息</li><li>301: 永久重定向</li><li>302: 临时重定向</li><li>304：ajax</li><li>400: 错误请求, Bad Request</li><li>401: 未授权</li><li>403: forbidden</li><li>404: not found</li><li>500: 服务端未知错误</li><li>502: Bad Gateway</li><li>503: 服务器不能正确处理请求</li><li>504: 网关超时Gateway Time-out<h2 id="HTTP是有状态还是无状态-如何记住上次请求的用户"><a href="#HTTP是有状态还是无状态-如何记住上次请求的用户" class="headerlink" title="HTTP是有状态还是无状态? 如何记住上次请求的用户?"></a>HTTP是有状态还是无状态? 如何记住上次请求的用户?</h2>HTTP是无状态的.<br>通过cookie来记住用户.<h2 id="什么是RESTful"><a href="#什么是RESTful" class="headerlink" title="什么是RESTful?"></a>什么是RESTful?</h2>一种编程风格, 主要采取动宾格式如”delete/user/id=10”<h2 id="TCP三次握手与四次挥手"><a href="#TCP三次握手与四次挥手" class="headerlink" title="TCP三次握手与四次挥手?"></a>TCP三次握手与四次挥手?</h2>三次握手:</li></ul><ol><li>客户端发起SYN报文后进入SYN_SENT状态</li><li>服务器接收报文后发送ACK+SYN确认应答报文, 然后进入SYN_RECD状态</li><li>客户端收到服务器的确认应答及同步报文后发送ACK报文进入ESTABLISHED状态</li><li>服务器接收客户端发来的ACK报文后也进入ESTABLISHED状态</li></ol><p>四次挥手:</p><ol><li>客户端发起FIN报文后进入FIN_WAIT1状态</li><li>服务端接收报文后发送ACK进入CLOSE_WAIT状态</li><li>客户端接收确认应答后进入FIN_WAIT2状态</li><li>服务端继续发送未发送完的数据, 发送完数据之后服务端发送FIN+ACK报文然后进入LAST_ACK状态</li><li>客户端收到服务端的关闭应答报文后发送ACK确认应答, 然后进入TIME_WAIT状态并等待2MSL.在2MSL时间内未收到服务器的确认应答表示服务器接收到了客户端最后发送的ACK确认应答</li><li>服务端CLOSE, 客户端CLOSE<h2 id="什么是流量控制-流量控制和拥塞控制是一种东西吗"><a href="#什么是流量控制-流量控制和拥塞控制是一种东西吗" class="headerlink" title="什么是流量控制? 流量控制和拥塞控制是一种东西吗?"></a>什么是流量控制? 流量控制和拥塞控制是一种东西吗?</h2>流量控制：如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。<br>拥塞控制：拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。</li></ol><h2 id="如何用UDP实现可靠性传输"><a href="#如何用UDP实现可靠性传输" class="headerlink" title="如何用UDP实现可靠性传输?"></a>如何用UDP实现可靠性传输?</h2><ul><li>采用确认序列</li><li>拥塞避免</li><li>超时重传</li><li>流量控制<h2 id="如何查找域名对应IP"><a href="#如何查找域名对应IP" class="headerlink" title="如何查找域名对应IP?"></a>如何查找域名对应IP?</h2>浏览器缓存, 系统缓存, MAC上缓存, ISP缓存, DNS缓存, DNS查询</li></ul><h2 id="什么是ACID-具体"><a href="#什么是ACID-具体" class="headerlink" title="什么是ACID? 具体?"></a>什么是ACID? 具体?</h2><ul><li>Atomic,原子性, 操作要么成功, 要么失败</li><li>Consistent, 一致性, 事物中一次和多次操作结果都相同</li><li>Isolation, 隔离性, 事物之间不相互影响</li><li>Durability, 已提交的事物对数据库所做的更新必须永久保存<h2 id="group-by-having-where区别"><a href="#group-by-having-where区别" class="headerlink" title="group by, having, where区别?"></a>group by, having, where区别?</h2>group by 是分组 在where之后<br>having是分组过滤, 在group by 之后<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select distinct id, count(*) from table_name where id &gt; 20 group by id having count(id) &gt; 3;</span><br></pre></td></tr></table></figure></li></ul><h2 id="MySQL如何解决RC-RP带来的问题-什么是MVCC"><a href="#MySQL如何解决RC-RP带来的问题-什么是MVCC" class="headerlink" title="MySQL如何解决RC, RP带来的问题? 什么是MVCC?"></a>MySQL如何解决RC, RP带来的问题? 什么是MVCC?</h2><p>使用MVCC解决RC, 使用MVCC+Next-key lock解决RP<br>MVCC(Multi-Version Concurrency Control, 多版本并发控制), 通过在记录行添加两列字段, 创建版本号与删除版本号进行控制</p><ul><li>读取: 读取创建版本号早于当前版本号并且删除版本号大于当前版本号的字段</li><li>删除: 删除时将原数据行的删除版本号改为当前事物版本号</li><li>更新: 复制原数据行, 将新行数据创建版本改为当前事物版本, 原数据行的删除数据版本号改为当前事物版本号<h2 id="为什么Redis是单线程还这么快"><a href="#为什么Redis是单线程还这么快" class="headerlink" title="为什么Redis是单线程还这么快?"></a>为什么Redis是单线程还这么快?</h2></li><li>多路复用</li><li>存储在内存中<h2 id="Redis主从复制模式下-主挂了怎么办"><a href="#Redis主从复制模式下-主挂了怎么办" class="headerlink" title="Redis主从复制模式下, 主挂了怎么办?"></a>Redis主从复制模式下, 主挂了怎么办?</h2>通过哨兵模式, 主服务器挂了之后从服务器会通过选举选出一个新的主服务器<h2 id="Redis底层数据结构-有哪些数据类型-跳跃表如何实现-压缩列表是什么"><a href="#Redis底层数据结构-有哪些数据类型-跳跃表如何实现-压缩列表是什么" class="headerlink" title="Redis底层数据结构(有哪些数据类型)? 跳跃表如何实现? 压缩列表是什么?"></a>Redis底层数据结构(有哪些数据类型)? 跳跃表如何实现? 压缩列表是什么?</h2></li><li>string类型</li><li>list类型</li><li>字典</li><li>跳跃表: 通过链表实现类似于二分查找的功能</li><li>整数集合</li><li>压缩列表: 将字段按照一定地规则编码在一块连续的内存区域, 目的是解决内存<h2 id="如何防止缓存雪崩"><a href="#如何防止缓存雪崩" class="headerlink" title="如何防止缓存雪崩?"></a>如何防止缓存雪崩?</h2>雪崩现象主要是指缓存大面积失效导致大量请求需要数据库处理, 从而导致系统性能下降.<br>解决办法:</li><li>设置不同的失效时间</li><li>设置二级缓存</li><li>真正大面积失效后通过对查询数据库请求进行并发限制<h2 id="如何防止穿透"><a href="#如何防止穿透" class="headerlink" title="如何防止穿透?"></a>如何防止穿透?</h2>穿透是指客户端查询大量缓存中不存在的数据, 可能是数据库攻击<br>解决办法:</li><li>布隆过滤, 将不可能存在的请求字段进行过滤</li><li>将查询为空的请求也进行缓存, 缓存时间设置短一些<h2 id="如何保证缓存与数据库的双写一致性"><a href="#如何保证缓存与数据库的双写一致性" class="headerlink" title="如何保证缓存与数据库的双写一致性?"></a>如何保证缓存与数据库的双写一致性?</h2>读取数据时, 若缓存中不存在则向数据库中查询, 然后更新缓存<br>修改时, 先删除缓存, 然后再更新数据库.<br>但上述修改方案会出现删除缓存, 数据库更新还未来得及完成时, 出现其它请求, 导致缓存中的数据是旧数据. 解决办法:</li><li>更新时删除缓存, 更新完数据库之后再删除缓存, 但会在一段时间造成脏读现象的出现</li><li>更新时将缓存设置为指定值, 其他请求查询时若发现缓存字段为指定值则进入循环等待, 等待数据库更新完成, 若未在指定期间更新完成则查询数据库.<h2 id="原码-反码-补码"><a href="#原码-反码-补码" class="headerlink" title="原码, 反码, 补码"></a>原码, 反码, 补码</h2>负数的原码左边第一位为1<br>正数的反码为其本身; 负数的反码为符号位不变, 其余位取反<br>正数的补码为其本身; 负数的补码为符号位不变, 其余为取反然后再加上1<br>##<h2 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式?"></a>进程间的通信方式?</h2></li><li>管道, 匿名管道</li><li>信号</li><li>信号量</li><li>消息队列</li><li>套接字</li><li>共享文件: 效率高<h2 id="CPU占用率100-怎么查"><a href="#CPU占用率100-怎么查" class="headerlink" title="CPU占用率100%怎么查?"></a>CPU占用率100%怎么查?</h2></li></ul><ol><li>top    # 或ps -ef | grep java</li><li>ps -mp pid -o THREAD,tid,time # 命令查看该进程的线程情况, 发现该进程有一个线程占用率很高</li><li>jstack pid | grep tid -A 30 # 2步中的id要转为16进制: printf “%x” &lt;线程id&gt;</li><li>df -h # 查看磁盘</li><li>du -sh *    # 查看文件目录占用情况<h2 id="线程和进程的区别-多线程和单线程的区别"><a href="#线程和进程的区别-多线程和单线程的区别" class="headerlink" title="线程和进程的区别? 多线程和单线程的区别?"></a>线程和进程的区别? 多线程和单线程的区别?</h2>线程与进程的区别:</li></ol><ul><li>进程由一个或多个线程组成</li><li>进程是系统资源调度的单位</li><li>进程上下文切换需要更改多个资源, 而线程只需修改部分寄存器内容</li><li>进程间通信麻烦, 线程共享地址空间</li></ul><p>多线程与单线程区别:</p><ul><li>在单个CPU上单线程运行速度快于多线程</li><li>在单个CPU上多线程是分配时间片来实现</li><li>线程之间共享资源有时需要其它复杂操作</li><li>多线程可以避免用户在等待复杂计算时不能进行其它操作</li><li>多CPU下, 多线程可以充分利用CPU资源<h2 id="为什么使用RabbitMQ-如何保证消息正确发送-如何保证消息接收方消费了消息-如何避免消费重复投递或重复消费-基于什么传输-消息如何分发-如何保证消息可靠传输-如何保证消息顺序性"><a href="#为什么使用RabbitMQ-如何保证消息正确发送-如何保证消息接收方消费了消息-如何避免消费重复投递或重复消费-基于什么传输-消息如何分发-如何保证消息可靠传输-如何保证消息顺序性" class="headerlink" title="为什么使用RabbitMQ? 如何保证消息正确发送? 如何保证消息接收方消费了消息? 如何避免消费重复投递或重复消费? 基于什么传输? 消息如何分发? 如何保证消息可靠传输? 如何保证消息顺序性?"></a>为什么使用RabbitMQ? 如何保证消息正确发送? 如何保证消息接收方消费了消息? 如何避免消费重复投递或重复消费? 基于什么传输? 消息如何分发? 如何保证消息可靠传输? 如何保证消息顺序性?</h2></li><li>异步, 销峰, 解耦</li><li>通过确认机制保证消息发送</li><li>信道确认</li><li>全局唯一id</li><li>基于信道传输</li><li>轮询方式发送</li><li>三个地方保证消息可靠传输 发送发: 通过确认机制 发送过程: 持久化 接收方: 不自动确认</li><li>通过对消息进行编号<h2 id="通常一个Xml映射文件-都会写一个Dao接口与之对应-请问-这个Dao接口的工作原理是什么-Dao接口里的方法-参数不同时-方法能重载吗"><a href="#通常一个Xml映射文件-都会写一个Dao接口与之对应-请问-这个Dao接口的工作原理是什么-Dao接口里的方法-参数不同时-方法能重载吗" class="headerlink" title="通常一个Xml映射文件, 都会写一个Dao接口与之对应, 请问, 这个Dao接口的工作原理是什么? Dao接口里的方法, 参数不同时, 方法能重载吗?"></a>通常一个Xml映射文件, 都会写一个Dao接口与之对应, 请问, 这个Dao接口的工作原理是什么? Dao接口里的方法, 参数不同时, 方法能重载吗?</h2>通过映射对应字段, 接口全限定名+方法名拼接字符串作为key值来定位MapperStatement<br>Mapper接口里的方法是不能重载的, 因为使用全限定名+方法名的保存和寻找策略.Mapper接口的原理是JDK动态代理, 代理对象会拦截接口方法, 转而执行sql.<h2 id="Spring中的IOC有几种注入方式"><a href="#Spring中的IOC有几种注入方式" class="headerlink" title="Spring中的IOC有几种注入方式?"></a>Spring中的IOC有几种注入方式?</h2></li><li>构造器注入</li><li>根据注解注入</li><li>setter<br>##<h2 id="Spring提供哪些配置方式"><a href="#Spring提供哪些配置方式" class="headerlink" title="Spring提供哪些配置方式?"></a>Spring提供哪些配置方式?</h2></li><li>基于XML</li><li>基于注解配置</li><li>基于Java API中的@Bean 和@Configuration<br>##<h2 id="什么是IOC-DI-什么是AOP-AOP的实现方式"><a href="#什么是IOC-DI-什么是AOP-AOP的实现方式" class="headerlink" title="什么是IOC/DI,什么是AOP? AOP的实现方式?"></a>什么是IOC/DI,什么是AOP? AOP的实现方式?</h2>ICO: 将由程序对对象的控制交给容器进行管理; Spring中使工厂模式+反射机制实现</li><li>DI: 由容器向组件注入资源 Spring中有两种IOC容器:</li><li>BeanFactory</li><li>ApplicationContext,上面的扩展</li><li></li><li>AOP: 面向切面编程 两种方式实现: 静态织入与动态代理<h2 id="Spring中Bean的Scope作用域"><a href="#Spring中Bean的Scope作用域" class="headerlink" title="Spring中Bean的Scope作用域?"></a>Spring中Bean的Scope作用域?</h2></li><li>sigleton</li><li>prototype</li><li>request</li><li>session</li><li>global session<h2 id="SpringMVC路由怎么写"><a href="#SpringMVC路由怎么写" class="headerlink" title="SpringMVC路由怎么写?"></a>SpringMVC路由怎么写?</h2>@RequestMapping()<h2 id="SpringMVC如何接受ajax"><a href="#SpringMVC如何接受ajax" class="headerlink" title="SpringMVC如何接受ajax?"></a>SpringMVC如何接受ajax?</h2>@RequestBody(), @ResponseBody()<br>##<h2 id="SpringMVC用到了那个核心servlet"><a href="#SpringMVC用到了那个核心servlet" class="headerlink" title="SpringMVC用到了那个核心servlet?"></a>SpringMVC用到了那个核心servlet?</h2>DispatchServlet<h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期?"></a>Bean的生命周期?</h2></li><li>通过构造器或工厂方法创建Bean实例</li><li>为Bean的属性设置值和对其它Bean的引用</li><li>将Bean实例传递给Bean前置处理器</li><li>调用Bean的初始化方法</li><li>将Bean实例传递给Bean后置处理器</li><li>使用Bean</li><li>当容器关闭时, 调用Bean的销毁方法</li></ul><h2 id="Linux下查看80端口是否被占用"><a href="#Linux下查看80端口是否被占用" class="headerlink" title="Linux下查看80端口是否被占用"></a>Linux下查看80端口是否被占用</h2><p>ps -ef | grep 80 netstat -an | grep : 80</p><h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><p>chmod 777 file 对file文件的拥有者, 同组, 其他用户都有写、读和执行权 r: 4 w: 2 x: 1</p><h2 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h2><ol><li>线程是否安全： HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；</li><li>效率： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</li><li>对Null key 和Null value的支持： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。</li><li>初始容量大小和每次扩充容量大小的不同 ： ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小（HashMap 中的tableSizeFor()方法保证，下面给出了源代码）。也就是说 HashMap 总是使用2的幂作为哈希表的大小,后面会介绍到为什么是2的幂次方。</li><li>底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">public static void quickSort(int[] array,int left,int right)&#123;</span><br><span class="line">    if(array==null)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int length = array.length;</span><br><span class="line">    if(length == right)&#123; // 防止输入数组的非下标长度，造成越界</span><br><span class="line">        right = right -1;</span><br><span class="line">    &#125;</span><br><span class="line">    if(left &gt; right)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int low = left;</span><br><span class="line">    int hight = right;</span><br><span class="line">    int key = array[left];</span><br><span class="line"></span><br><span class="line">    while(low&lt;hight)&#123;</span><br><span class="line">        while(low&lt;hight &amp;&amp; array[hight]&gt;=key)&#123;</span><br><span class="line">            hight --;</span><br><span class="line">        &#125;</span><br><span class="line">        array[low] = array[hight];</span><br><span class="line">        while(low&lt;hight &amp;&amp; array[low]&lt;=key)&#123;</span><br><span class="line">            low++;</span><br><span class="line">        &#125;</span><br><span class="line">        array[hight] = array[low];</span><br><span class="line">    &#125;</span><br><span class="line">    array[low] = key;   /** 被比较的数此时应该回到 low 位置 */</span><br><span class="line">    quickSort(array,left,low-1);</span><br><span class="line">    quickSort(array,low+1,right);</span><br><span class="line">&#125;</span><br><span class="line">/** 二分查找 */</span><br><span class="line">public static int binary(int[] array, int value)&#123;</span><br><span class="line">    int low = 0;</span><br><span class="line">    int high = array.length - 1; // 防止越界</span><br><span class="line">    while(low &lt;= high)&#123;</span><br><span class="line">        int middle = (low + high) / 2;</span><br><span class="line">        if(value == array[middle])&#123;</span><br><span class="line">            return middle;  // 下标</span><br><span class="line">        &#125;</span><br><span class="line">        if(value &gt; array[middle])&#123;</span><br><span class="line">            low = middle + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(value &lt; array[middle])&#123;</span><br><span class="line">            high = middle - 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; levels = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void helper(TreeNode node, int level) &#123;</span><br><span class="line">        // start the current level</span><br><span class="line">        if (levels.size() == level)</span><br><span class="line">            levels.add(new ArrayList&lt;Integer&gt;());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         // fulfil the current level</span><br><span class="line">         levels.get(level).add(node.val);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         // process child nodes for the next level</span><br><span class="line">         if (node.left != null)</span><br><span class="line">            helper(node.left, level + 1);</span><br><span class="line">         if (node.right != null)</span><br><span class="line">            helper(node.right, level + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        if (root == null) return levels;</span><br><span class="line">        helper(root, 0);</span><br><span class="line">        return levels;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">。</span><br></pre></td></tr></table></figure><p>前后端数据交互模式 JSON数据 并且封装了一个Result类<br>线程状态<br><a href="https://www.cnblogs.com/GooPolaris/p/8079490.html" target="_blank" rel="noopener">https://www.cnblogs.com/GooPolaris/p/8079490.html</a><br>java中，<strong>线程的状态使用一个枚举类型来描述的</strong>。这个枚举一共有6个值: <strong>NEW(新建)、RUNNABLE(运行)、BLOCKED(锁池)、TIMED_WAITING(定时等待)、WAITING(等待)、TERMINATED(终止、结束)。</strong><br><a href="https://images2017.cnblogs.com/blog/1182445/201712/1182445-20171222141718334-679964095.png" target="_blank" rel="noopener">https://images2017.cnblogs.com/blog/1182445/201712/1182445-20171222141718334-679964095.png</a><br><a href="https://img-blog.csdn.net/20180802230855612?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTg5MTg1NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" target="_blank" rel="noopener">https://img-blog.csdn.net/20180802230855612?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTg5MTg1NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70</a><br>SLEEP不会释放锁 WAIT会释放锁</p><h1 id="MySQL索引类型"><a href="#MySQL索引类型" class="headerlink" title="MySQL索引类型"></a>MySQL索引类型</h1><p><strong>1. B-Tree索引</strong><br>最常见的索引类型，基于B-Tree数据结构。B-Tree的基本思想是，所有值（被索引的列）都是排过序的，每个叶节点到跟节点距离相等。所以B-Tree适合用来查找某一范围内的数据，而且可以直接支持数据排序（ORDER BY）。但是当索引多列时，列的顺序特别重要，需要格外注意。InnoDB和MyISAM都支持B-Tree索引。InnoDB用的是一个变种B+Tree，而MyISAM为了节省空间对索引进行了压缩，从而牺牲了性能。<br><strong>2. Hash索引</strong><br>基于hash表。所以这种索引只支持精确查找，不支持范围查找，不支持排序。这意味着范围查找或ORDER BY都要依赖server层的额外工作。目前只有Memory引擎支持显式的hash索引（但是它的hash是nonunique的，冲突太多时也会影响查找性能）。Memory引擎默认的索引类型即是Hash索引，虽然它也支持B-Tree索引。<br><strong>3. Spatial (R-Tree)（空间）索引</strong><br>只有MyISAM引擎支持，并且支持的不好。可以忽略。<br><strong>4. Full-text索引</strong><br>主要用来查找文本中的关键字，而不是直接与索引中的值相比较。Full-text索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的WHERE语句的参数匹配。你可以对某列分别进行full-text索引和B-Tree索引，两者互不冲突。Full-text索引配合MATCH AGAINST操作使用，而不是一般的WHERE语句加LIKE。<br><strong>从物理存储角度</strong><br>1、聚集索引（clustered index）<br>2、非聚集索引（non-clustered index）<br><strong>从逻辑角度</strong><br>1、主键索引：主键索引是一种特殊的唯一索引，不允许有空值<br>2、普通索引或者单列索引<br>3、多列索引（复合索引）：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合<br>4、唯一索引或者非唯一索引<br>5、空间索引：空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，空间索引只能在存储引擎为MYISAM的表中创建<br><img alt="图片" data-src="https://uploader.shimo.im/f/CsANfq1AO4wFKP6v.png!thumbnail" class="lazyload"><br>1、unique|fulltext|spatial为可选参数，分别表示唯一索引、全文索引和空间索引；<br>2、index和key为同义词，两者作用相同，用来指定创建索引<br>3、col_name为需要创建索引的字段列，该列必须从数据表中该定义的多个列中选择；<br>4、index_name指定索引的名称，为可选参数，如果不指定，MYSQL默认col_name为索引值；<br>5、length为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度；<br>6、asc或desc指定升序或降序的索引值存储</p>]]></content>
    
    
    <summary type="html">经常被问到的题</summary>
    
    
    
    <category term="总结" scheme="http://yoursite.com/categories/总结/"/>
    
    
    <category term="面经" scheme="http://yoursite.com/tags/面经/"/>
    
    <category term="总结" scheme="http://yoursite.com/tags/总结/"/>
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
</feed>
